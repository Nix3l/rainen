#include "gfx.h"
#include "cglm/cam.h"
#include "memory/memory.h"
#include "util/util.h"

gfx_ctx_t gfx_ctx;

// start of black magic --------------

// BACKEND_FUNC_XMACRO(function name, parameters)
// will get expanded into all the necessary function definitions
#define BACKEND_FUNCS_LIST \
    BACKEND_FUNC_XMACRO(mesh_init, mesh_t* mesh, mesh_info_t info) \
    BACKEND_FUNC_XMACRO(mesh_destroy, mesh_t* mesh) \
    BACKEND_FUNC_XMACRO(texture_init, texture_t* texture, texture_info_t info) \
    BACKEND_FUNC_XMACRO(texture_destroy, texture_t* texture) \
    BACKEND_FUNC_XMACRO(sampler_init, sampler_t* sampler, sampler_info_t info) \
    BACKEND_FUNC_XMACRO(sampler_destroy, sampler_t* sampler) \
    BACKEND_FUNC_XMACRO(shader_init, shader_t* shader, shader_info_t info) \
    BACKEND_FUNC_XMACRO(shader_destroy, shader_t* shader) \
    BACKEND_FUNC_XMACRO(shader_update_uniforms, shader_t* shader, range_t uniforms) \

#define BACKEND_FUNC_XMACRO(_name, ...) typedef void (*_name ## _func) (__VA_ARGS__);
BACKEND_FUNCS_LIST;
#undef BACKEND_FUNC_XMACRO

#define BACKEND_FUNC_XMACRO(_name, ...) _name ## _func _name;
typedef struct backend_jumptable_t {
    BACKEND_FUNCS_LIST;
} backend_jumptable_t;
#undef BACKEND_FUNC_XMACRO

static backend_jumptable_t backend_jumptables[GFX_BACKEND_NUM] = {0};
static backend_jumptable_t* backend = NULL;

// define backend-specific functions
// gl
#define BACKEND_FUNC_XMACRO(_name, ...) static void gl_ ## _name(__VA_ARGS__);
BACKEND_FUNCS_LIST;
#undef BACKEND_FUNC_XMACRO

static void init_jumptables() {
    #define BACKEND_FUNC_XMACRO(_name, ...) ._name = gl_ ## _name,
    backend_jumptables[GFX_BACKEND_GL] = (backend_jumptable_t) {
        BACKEND_FUNCS_LIST
    };
    #undef BACKEND_FUNC_XMACRO

    backend = &backend_jumptables[gfx_ctx.backend];
}

#undef BACKEND_FUNCS_LIST
#undef BACKEND_FUNC_XMACRO

// end of black magic ----------------

static gfx_respool_t mesh_pool;
static gfx_respool_t texture_pool;
static gfx_respool_t sampler_pool;
static gfx_respool_t shader_pool;

static gfx_respool_t gfx_respool_alloc(u32 capacity, u32 res_bytes, u32 internal_bytes) {
    return (gfx_respool_t) {
        .capacity = capacity,
        .data_pool = pool_alloc(capacity, res_bytes, EXPAND_TYPE_IMMUTABLE),
        .gfx_pool = pool_alloc(capacity, internal_bytes, EXPAND_TYPE_IMMUTABLE),
    };
}

// TODO(nix3l): inline these?
static void* gfx_respool_push_data(gfx_respool_t* pool, handle_t* slot) {
    return pool_push(&pool->data_pool, slot);
}

static void* gfx_respool_push_internal(gfx_respool_t* pool, handle_t* slot) {
    return pool_push(&pool->gfx_pool, slot);
}

static void* gfx_respool_data(gfx_respool_t* pool, handle_t slot) {
    return pool_get(&pool->data_pool, slot);
}

static void* gfx_respool_internal(gfx_respool_t* pool, handle_t slot) {
    return pool_get(&pool->gfx_pool, slot);
}

static void gfx_respool_free_data(gfx_respool_t* pool, handle_t slot) {
    pool_free(&pool->data_pool, slot);
}

static void gfx_respool_free_internal(gfx_respool_t* pool, handle_t slot) {
    pool_free(&pool->gfx_pool, slot);
}

static void gfx_respool_destroy(gfx_respool_t* pool) {
    pool->capacity = 0;
    pool_destroy(&pool->data_pool);
    pool_destroy(&pool->gfx_pool);
}

void gfx_init(gfx_backend_t backend) {
    gfx_backend_info_t opengl_core_info = (gfx_backend_info_t) {
        .backend = GFX_BACKEND_GL,
        .version_major = 4,
        .version_minor = 3,
        .version_str = "4.3",
        .name = "glcore",
        .name_pretty = "OpenGL",
        .supported = GFX_SUPPORT_GL,
        .mesh_internal_size = sizeof(gl_mesh_internal_t),
        .texture_internal_size = sizeof(gl_texture_internal_t),
        .sampler_internal_size = sizeof(gl_sampler_internal_t),
        .shader_internal_size = sizeof(gl_shader_internal_t),
    };

    gfx_ctx = (gfx_ctx_t) {
        .backend = backend,
        .backend_info = {
            (gfx_backend_info_t) {0},
            opengl_core_info,
        },
    };

    gfx_backend_info_t curr_backend_info = gfx_ctx.backend_info[backend];
    if(!curr_backend_info.supported)
        PANIC("chosen backend is not supported on current OS\n");

    // for now, keep immutable
    mesh_pool = gfx_respool_alloc(GFX_MAX_MESHES, sizeof(mesh_t), curr_backend_info.mesh_internal_size);
    gfx_ctx.mesh_pool = &mesh_pool;

    texture_pool = gfx_respool_alloc(GFX_MAX_TEXTURES, sizeof(texture_t), curr_backend_info.texture_internal_size);
    gfx_ctx.texture_pool = &texture_pool;

    sampler_pool = gfx_respool_alloc(GFX_MAX_SAMPLERS, sizeof(sampler_t), curr_backend_info.sampler_internal_size);
    gfx_ctx.sampler_pool = &sampler_pool;

    shader_pool = gfx_respool_alloc(GFX_MAX_SHADERS, sizeof(shader_t), curr_backend_info.shader_internal_size);
    gfx_ctx.shader_pool = &shader_pool;

    init_jumptables();
}

void gfx_terminate() {
    gfx_respool_destroy(gfx_ctx.mesh_pool);
    gfx_respool_destroy(gfx_ctx.texture_pool);
    gfx_respool_destroy(gfx_ctx.sampler_pool);
    gfx_respool_destroy(gfx_ctx.shader_pool);
}

gfx_backend_t gfx_backend() {
    return gfx_ctx.backend;
}

gfx_backend_info_t gfx_backend_info() {
    return gfx_ctx.backend_info[gfx_ctx.backend];
}

// API
static u32 mesh_format_num_attributes(mesh_format_t format) {
    switch(format) {
        case MESH_FORMAT_X3T2N3: return 3;
        default: UNREACHABLE; return 0;
    }
}

mesh_attribute_t mesh_attribute(void *data, u32 size, u32 dimensions) {
    return (mesh_attribute_t) {
        .dimensions = dimensions,
        .data = range_new(data, size),
    };
}

vmesh_t mesh_alloc() {
    vmesh_t vmesh = {0};
    mesh_t* mesh = gfx_respool_push_data(gfx_ctx.mesh_pool, &vmesh.id);
    mem_clear(mesh, sizeof(mesh_t));
    return vmesh;
}

void mesh_init(vmesh_t vmesh, mesh_info_t info) {
    mesh_t* mesh = gfx_respool_data(gfx_ctx.mesh_pool, vmesh.id);

    if(info.format == MESH_FORMAT_INVALID) {
        LOG_ERR("mesh format *must* be supplied\n");
        return;
    }

    if(info.index_type == MESH_INDEX_TYPE_UNDEFINED)
        info.index_type = info.indices.size == 0 ? MESH_INDEX_TYPE_NONE : MESH_INDEX_TYPE_32b;

    if(info.primitive == MESH_PRIMITIVE_DEFAULT)
        info.primitive = MESH_PRIMITIVE_TRIANGLES;

    if(info.winding == MESH_WINDING_DEFAULT)
        info.winding = MESH_WINDING_CCW;

    mesh->format = info.format;
    mesh->index_type = info.index_type;
    mesh->primitive = info.primitive;
    mesh->winding = info.winding;

    backend->mesh_init(mesh, info);
    return;
}

void mesh_discard(vmesh_t vmesh) {
    mesh_t* mesh = gfx_respool_data(gfx_ctx.mesh_pool, vmesh.id);
    if(!mesh) return;
    backend->mesh_destroy(mesh);
    gfx_respool_free_internal(gfx_ctx.mesh_pool, mesh->internal);
}

void mesh_destroy(vmesh_t vmesh) {
    gfx_respool_free_data(gfx_ctx.mesh_pool, vmesh.id);
}

vmesh_t mesh_new(mesh_info_t info) {
    vmesh_t mesh = mesh_alloc();
    mesh_init(mesh, info);
    return mesh;
}

vtex_t texture_alloc() {
    vtex_t vtex = {0};
    texture_t* texture = gfx_respool_push_data(gfx_ctx.texture_pool, vtex.id);
    return vtex;
}

void texture_init(vtex_t texture, texture_info_t info);
void texture_discard(vtex_t texture);
void texture_destroy(vtex_t texture);

texture_t texture_new(texture_info_t info) {
    texture_t texture = {0};

    if(info.type == TEXTURE_TYPE_UNDEFINED) info.type = TEXTURE_TYPE_2D;
    if(info.mipmaps == 0) info.mipmaps = 1;

    texture.type = info.type;
    texture.format = info.format;
    texture.width = info.width;
    texture.height = info.height;
    texture.mipmaps = info.mipmaps;

    backend->texture_init(&texture, info);
    return texture;
}

void texture_destroy(texture_t* texture) {
    backend->texture_destroy(texture);
    gfx_respool_free_internal(gfx_ctx.texture_pool, texture->internal);
}

sampler_t sampler_new(sampler_info_t info) {
    sampler_t sampler = {0};

    if(info.wrap != TEXTURE_WRAP_UNDEFINED) {
        info.u_wrap = info.wrap;
        info.v_wrap = info.wrap;
    }

    if(info.filter != TEXTURE_FILTER_UNDEFINED) {
        info.min_filter = info.filter;
        info.mag_filter = info.filter;
    }

    sampler.u_wrap = info.u_wrap;
    sampler.v_wrap = info.v_wrap;
    sampler.min_filter = info.min_filter;
    sampler.mag_filter = info.mag_filter;

    backend->sampler_init(&sampler, info);
    return sampler;
}

void sampler_destroy(sampler_t* sampler) {
    backend->sampler_destroy(sampler);
    gfx_respool_free_internal(gfx_ctx.sampler_pool, sampler->internal);
}

static u32 uniform_type_get_bytes(uniform_type_t type) {
    // TODO(nix3l): padding??
    switch (type) {
        case UNIFORM_TYPE_i32: return 4;
        case UNIFORM_TYPE_u32: return 4;
        case UNIFORM_TYPE_f32: return 4;
        case UNIFORM_TYPE_v2f: return 8;
        case UNIFORM_TYPE_v2i: return 8;
        case UNIFORM_TYPE_v3f: return 12;
        case UNIFORM_TYPE_v3i: return 12;
        case UNIFORM_TYPE_v4f: return 16;
        case UNIFORM_TYPE_v4i: return 16;
        case UNIFORM_TYPE_mat4: return 64;
        default: UNREACHABLE; return 0;
    }
}

static char* shader_type_name(shader_pass_type_t type) {
    switch(type) {
        case SHADER_PASS_VERTEX: return "vertex";
        case SHADER_PASS_FRAGMENT: return "fragment";
        case SHADER_PASS_COMPUTE: return "compute";
        default: return "unknown";
    }
}

shader_t shader_new(shader_info_t info) {
    shader_t shader = {0};

    memcpy(shader.name, info.name, sizeof(shader.name));
    memcpy(shader.pretty_name, info.pretty_name, sizeof(shader.pretty_name));
    memcpy(shader.attribs, info.attribs, sizeof(shader.attribs));

    shader.vertex_pass = (shader_pass_t) {
        .src = info.vertex_src,
        .type = SHADER_PASS_VERTEX
    };

    shader.fragment_pass = (shader_pass_t) {
        .src = info.fragment_src,
        .type = SHADER_PASS_FRAGMENT
    };

    backend->shader_init(&shader, info);
    return shader;
}

void shader_destroy(shader_t* shader) {
    backend->shader_destroy(shader);
    gfx_respool_free_internal(gfx_ctx.shader_pool, shader->internal);
}

void shader_update_uniforms(shader_t* shader, range_t data) {
    backend->shader_update_uniforms(shader, data);
}

// OPENGL-SPECIFIC
// MESH
static u32 gl_vbo_create(u32 attribute, u32 dimensions, void* data, u32 bytes) {
    u32 vbo;
    glGenBuffers(1, &vbo);

    glBindBuffer(GL_ARRAY_BUFFER, vbo);

    glBufferData(GL_ARRAY_BUFFER, bytes, data, GL_STATIC_DRAW);
    glVertexAttribPointer(attribute, dimensions, GL_FLOAT, GL_FALSE, 0, NULL);

    glBindBuffer(GL_ARRAY_BUFFER, 0);
    return vbo;
}

static u32 gl_indices_vbo_create(u32* indices, u32 bytes) {
    u32 vbo;
    glGenBuffers(1, &vbo);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, bytes, indices, GL_STATIC_DRAW);

    return vbo;
}

static void gl_mesh_init(mesh_t* mesh, mesh_info_t info) {
    gl_mesh_internal_t* glmesh = gfx_respool_push_internal(gfx_ctx.mesh_pool, &mesh->internal);
    mem_clear(glmesh, sizeof(gl_mesh_internal_t));

    glGenVertexArrays(1, &glmesh->vao);
    glBindVertexArray(glmesh->vao);

    for(u32 i = 0; i < mesh_format_num_attributes(info.format); i ++) {
        mesh_attribute_t attribute = info.attributes[i];
        glmesh->vbos[i] = gl_vbo_create(i, attribute.dimensions, attribute.data.ptr, attribute.data.size);
    }

    if(info.index_type != MESH_INDEX_TYPE_NONE)
        glmesh->index_vbo = gl_indices_vbo_create(info.indices.ptr, info.indices.size);

    glBindVertexArray(0);
}

static void gl_mesh_destroy(mesh_t* mesh) {
    gl_mesh_internal_t* glmesh = gfx_respool_internal(gfx_ctx.mesh_pool, mesh->internal);
    if(!glmesh) return;

    // glDeleteBuffers simply ignores any 0's or invalid ids
    // so this is perfectly fine
    glDeleteBuffers(GFX_MAX_VERTEX_ATTRIBS, glmesh->vbos);
    glDeleteBuffers(1, &glmesh->index_vbo);
    glDeleteVertexArrays(1, &glmesh->vao);

    gfx_respool_free_internal(gfx_ctx.mesh_pool, mesh->internal);
}

// TEXTURE
static u32 gl_texture_bind_target(texture_type_t type) {
    switch(type) {
        case TEXTURE_TYPE_2D: return GL_TEXTURE_2D;
        default: UNREACHABLE; return 0;
    }
}

static u32 gl_texture_format(texture_format_t format) {
    switch(format) {
        case TEXTURE_FORMAT_R8:
        case TEXTURE_FORMAT_R8I:
        case TEXTURE_FORMAT_R8UI:
        case TEXTURE_FORMAT_R16:
        case TEXTURE_FORMAT_R16F:
        case TEXTURE_FORMAT_R16I:
        case TEXTURE_FORMAT_R16UI:
        case TEXTURE_FORMAT_R32F:
        case TEXTURE_FORMAT_R32I:
        case TEXTURE_FORMAT_R32UI:
            return GL_RED;
        case TEXTURE_FORMAT_RG8:
        case TEXTURE_FORMAT_RG8I:
        case TEXTURE_FORMAT_RG8UI:
        case TEXTURE_FORMAT_RG16:
        case TEXTURE_FORMAT_RG16F:
        case TEXTURE_FORMAT_RG16I:
        case TEXTURE_FORMAT_RG16UI:
        case TEXTURE_FORMAT_RG32F:
        case TEXTURE_FORMAT_RG32I:
        case TEXTURE_FORMAT_RG32UI:
            return GL_RG;
        case TEXTURE_FORMAT_RGB8:
        case TEXTURE_FORMAT_RGB8I:
        case TEXTURE_FORMAT_RGB8UI:
        case TEXTURE_FORMAT_RGB16F:
        case TEXTURE_FORMAT_RGB16I:
        case TEXTURE_FORMAT_RGB16UI:
        case TEXTURE_FORMAT_RGB32F:
        case TEXTURE_FORMAT_RGB32I:
        case TEXTURE_FORMAT_RGB32UI:
            return GL_RGB;
        case TEXTURE_FORMAT_RGBA8:
        case TEXTURE_FORMAT_RGBA8I:
        case TEXTURE_FORMAT_RGBA8UI:
        case TEXTURE_FORMAT_RGBA16F:
        case TEXTURE_FORMAT_RGBA16I:
        case TEXTURE_FORMAT_RGBA16UI:
        case TEXTURE_FORMAT_RGBA32F:
        case TEXTURE_FORMAT_RGBA32I:
        case TEXTURE_FORMAT_RGBA32UI:
            return GL_RGBA;
        case TEXTURE_FORMAT_DEPTH:
            return GL_DEPTH_COMPONENT;
        case TEXTURE_FORMAT_DEPTH_STENCIL:
            return GL_DEPTH_STENCIL;
        default:
            UNREACHABLE;
            return 0;
    }
}

static u32 gl_texture_internalformat(texture_format_t format) {
    switch(format) {
        // one channel
        case TEXTURE_FORMAT_R8: return GL_R8;
        case TEXTURE_FORMAT_R8I: return GL_R8I;
        case TEXTURE_FORMAT_R8UI: return GL_R8UI;

        case TEXTURE_FORMAT_R16: return GL_R16;
        case TEXTURE_FORMAT_R16F: return GL_R16F;
        case TEXTURE_FORMAT_R16I: return GL_R16I;
        case TEXTURE_FORMAT_R16UI: return GL_R16UI;

        case TEXTURE_FORMAT_R32F: return GL_R32F;
        case TEXTURE_FORMAT_R32I: return GL_R32I;
        case TEXTURE_FORMAT_R32UI: return GL_R32UI;

        // 2 channels
        case TEXTURE_FORMAT_RG8: return GL_RG8;
        case TEXTURE_FORMAT_RG8I: return GL_RG8I;
        case TEXTURE_FORMAT_RG8UI: return GL_RG8UI;

        case TEXTURE_FORMAT_RG16: return GL_RG16;
        case TEXTURE_FORMAT_RG16F: return GL_RG16F;
        case TEXTURE_FORMAT_RG16I: return GL_RG16I;
        case TEXTURE_FORMAT_RG16UI: return GL_RG16UI;

        case TEXTURE_FORMAT_RG32F: return GL_RG32F;
        case TEXTURE_FORMAT_RG32I: return GL_RG32I;
        case TEXTURE_FORMAT_RG32UI: return GL_R32UI;

        // 3 channels
        case TEXTURE_FORMAT_RGB8: return GL_RGB8;
        case TEXTURE_FORMAT_RGB8I: return GL_RGB8I;
        case TEXTURE_FORMAT_RGB8UI: return GL_RGB8UI;

        case TEXTURE_FORMAT_RGB16F: return GL_RGB16F;
        case TEXTURE_FORMAT_RGB16I: return GL_RGB16I;
        case TEXTURE_FORMAT_RGB16UI: return GL_RGB16UI;

        case TEXTURE_FORMAT_RGB32F: return GL_RGB32F;
        case TEXTURE_FORMAT_RGB32I: return GL_RGB32I;
        case TEXTURE_FORMAT_RGB32UI: return GL_RGB32UI;

        // 4 channels
        case TEXTURE_FORMAT_RGBA8: return GL_RGBA8;
        case TEXTURE_FORMAT_RGBA8I: return GL_RGBA8I;
        case TEXTURE_FORMAT_RGBA8UI: return GL_RGBA8UI;

        case TEXTURE_FORMAT_RGBA16F: return GL_RGBA16F;
        case TEXTURE_FORMAT_RGBA16I: return GL_RGBA16I;
        case TEXTURE_FORMAT_RGBA16UI: return GL_RGBA16UI;

        case TEXTURE_FORMAT_RGBA32F: return GL_RGBA32F;
        case TEXTURE_FORMAT_RGBA32I: return GL_RGBA32I;
        case TEXTURE_FORMAT_RGBA32UI: return GL_RGBA32UI;

        // depth/stencil
        case TEXTURE_FORMAT_DEPTH: GL_DEPTH_COMPONENT32F;
        case TEXTURE_FORMAT_DEPTH_STENCIL: return GL_DEPTH32F_STENCIL8;

        default: UNREACHABLE; return 0;
    }
}

static u32 gl_texture_data_type(texture_format_t format) {
    switch(format) {
        case TEXTURE_FORMAT_R8I:
        case TEXTURE_FORMAT_RG8I:
        case TEXTURE_FORMAT_RGB8I:
        case TEXTURE_FORMAT_RGBA8I:
            return GL_BYTE;
        case TEXTURE_FORMAT_R8:
        case TEXTURE_FORMAT_R8UI:
        case TEXTURE_FORMAT_RG8:
        case TEXTURE_FORMAT_RG8UI:
        case TEXTURE_FORMAT_RGB8:
        case TEXTURE_FORMAT_RGB8UI:
        case TEXTURE_FORMAT_RGBA8:
        case TEXTURE_FORMAT_RGBA8UI:
            return GL_UNSIGNED_BYTE;
        case TEXTURE_FORMAT_R16I:
        case TEXTURE_FORMAT_RG16I:
        case TEXTURE_FORMAT_RGB16I:
        case TEXTURE_FORMAT_RGBA16I:
            return GL_SHORT;
        case TEXTURE_FORMAT_R16:
        case TEXTURE_FORMAT_R16UI:
        case TEXTURE_FORMAT_RG16:
        case TEXTURE_FORMAT_RG16UI:
        case TEXTURE_FORMAT_RGB16UI:
        case TEXTURE_FORMAT_RGBA16UI:
            return GL_UNSIGNED_SHORT;
        case TEXTURE_FORMAT_R32UI:
        case TEXTURE_FORMAT_RG32UI:
        case TEXTURE_FORMAT_RGB32UI:
        case TEXTURE_FORMAT_RGBA32UI:
            return GL_UNSIGNED_INT;
        case TEXTURE_FORMAT_R32I:
        case TEXTURE_FORMAT_RG32I:
        case TEXTURE_FORMAT_RGB32I:
        case TEXTURE_FORMAT_RGBA32I:
            return GL_INT;
        case TEXTURE_FORMAT_R16F:
        case TEXTURE_FORMAT_RG16F:
        case TEXTURE_FORMAT_RGB16F:
        case TEXTURE_FORMAT_RGBA16F:
            return GL_HALF_FLOAT;
        case TEXTURE_FORMAT_R32F:
        case TEXTURE_FORMAT_RG32F:
        case TEXTURE_FORMAT_RGB32F:
        case TEXTURE_FORMAT_RGBA32F:
            return GL_FLOAT;
        case TEXTURE_FORMAT_DEPTH:
            return GL_FLOAT;
        case TEXTURE_FORMAT_DEPTH_STENCIL:
            return GL_UNSIGNED_INT_24_8;
        default:
            UNREACHABLE;
            return 0;
    }
}

static void gl_texture_init(texture_t* texture, texture_info_t info) {
    gl_texture_internal_t* gltex = gfx_respool_push_internal(gfx_ctx.texture_pool, &texture->internal);
    mem_clear(gltex, sizeof(gl_texture_internal_t));

    u32 target = gl_texture_bind_target(info.type);

    glGenTextures(1, &gltex->id);
    glBindTexture(target, gltex->id);

    glTexImage2D(
        target,
        0,
        gl_texture_internalformat(info.format),
        info.width,
        info.height,
        0, // TODO(nix3l): border?
        gl_texture_format(info.format),
        gl_texture_data_type(info.format),
        info.data.ptr
    );

    glBindTexture(target, 0);
}

static void gl_texture_destroy(texture_t* texture) {
    gl_texture_internal_t* gltex = gfx_respool_internal(gfx_ctx.texture_pool, texture->internal);
    if(!gltex) return;
    glDeleteTextures(1, &gltex->id);
    gfx_respool_free_internal(gfx_ctx.texture_pool, texture->internal);
}

// SAMPLER
static u32 gl_texture_filter(texture_filter_t filter) {
    switch(filter) {
        case TEXTURE_FILTER_NEAREST: return GL_NEAREST;
        case TEXTURE_FILTER_LINEAR: return GL_LINEAR;
        default: UNREACHABLE; return 0;
    }
}

static u32 gl_texture_wrap(texture_wrap_t wrap) {
    switch(wrap) {
        case TEXTURE_WRAP_REPEAT: return GL_REPEAT;
        case TEXTURE_WRAP_MIRRORED_REPEAT: return GL_MIRRORED_REPEAT;
        case TEXTURE_WRAP_CLAMP_TO_EDGE: return GL_CLAMP_TO_EDGE;
        default: UNREACHABLE; return 0;
    }
}

static void gl_sampler_init(sampler_t* sampler, sampler_info_t info) {
    gl_sampler_internal_t* glsampler = gfx_respool_push_internal(gfx_ctx.sampler_pool, &sampler->internal);
    mem_clear(glsampler, sizeof(gl_sampler_internal_t));

    glGenSamplers(1, &glsampler->id);
    glSamplerParameteri(glsampler->id, GL_TEXTURE_MIN_FILTER, gl_texture_filter(info.min_filter));
    glSamplerParameteri(glsampler->id, GL_TEXTURE_MAG_FILTER, gl_texture_filter(info.mag_filter));
    glSamplerParameteri(glsampler->id, GL_TEXTURE_WRAP_R, gl_texture_wrap(info.u_wrap));
    glSamplerParameteri(glsampler->id, GL_TEXTURE_WRAP_S, gl_texture_wrap(info.v_wrap));
    // TODO(nix3l): update for GL_TEXTURE_WRAP_T
}

static void gl_sampler_destroy(sampler_t* sampler) {
    gl_sampler_internal_t* glsampler = gfx_respool_internal(gfx_ctx.sampler_pool, sampler->internal);
    if(!glsampler) return;
    glDeleteSamplers(1, &glsampler->id);
}

// SHADER
static u32 gl_shader_type(shader_pass_type_t type) {
    switch(type) {
        case SHADER_PASS_VERTEX: return GL_VERTEX_SHADER;
        case SHADER_PASS_FRAGMENT: return GL_FRAGMENT_SHADER;
        case SHADER_PASS_COMPUTE: return GL_COMPUTE_SHADER;
        default: UNREACHABLE; return 0;
    }
}

static u32 gl_compile_shader(range_t src, shader_pass_type_t type) {
    u32 id = glCreateShader(gl_shader_type(type));

    glShaderSource(id, 1, (const char* const*)&src.ptr, NULL);
    glCompileShader(id);

    i32 success;
    glGetShaderiv(id, GL_COMPILE_STATUS, &success);

    if(!success) {
        char log[512];
        glGetShaderInfoLog(id, sizeof(log), NULL, log);
        LOG_ERR("error compiling %s shader:\n", shader_type_name(type));
        LOG_ERR("%s\n", log);
    }

    return id;
}

static void gl_shader_init(shader_t* shader, shader_info_t info) {
    gl_shader_internal_t* glshader = gfx_respool_push_internal(gfx_ctx.shader_pool, &shader->internal);
    mem_clear(glshader, sizeof(gl_shader_internal_t));

    glshader->program = glCreateProgram();

    u32 vs_id = gl_compile_shader(info.vertex_src, SHADER_PASS_VERTEX);
    u32 fs_id = gl_compile_shader(info.fragment_src, SHADER_PASS_FRAGMENT);

    glAttachShader(glshader->program, vs_id);
    glAttachShader(glshader->program, fs_id);

    for(u32 i = 0; i < GFX_MAX_VERTEX_ATTRIBS; i ++) {
        shader_vertex_attribute_t attrib = info.attribs[i];
        if(!attrib.name) break;
        glBindAttribLocation(glshader->program, i, attrib.name);
    }

    glLinkProgram(glshader->program);
    glValidateProgram(glshader->program);

    i32 success;
    glGetProgramiv(glshader->program, GL_LINK_STATUS, &success);

    if(!success) {
        char log[512];
        glGetProgramInfoLog(glshader->program, 512, NULL, log);
        LOG_ERR("failed to link shader [%s]:\n%s\n", info.pretty_name, log);
    }

    for(u32 i = 0; i < GFX_MAX_UNIFORMS; i ++) {
        uniform_t uniform_info = info.uniforms[i];
        if(!uniform_info.name || uniform_info.type == UNIFORM_TYPE_INVALID) {
            shader->uniform_block.num = i + 1;
            break;
        }

        uniform_t* shader_uniform = &shader->uniform_block.uniforms[i];
        shader_uniform->glid = glGetUniformLocation(glshader->program, uniform_info.name);
        if(shader_uniform->glid == (u32)-1) LOG_ERR("couldnt find uniform [%s] in shader [%s]\n", uniform_info.name, info.pretty_name);
        shader_uniform->name = uniform_info.name;
        shader_uniform->type = uniform_info.type;
    }

    glDetachShader(glshader->program, vs_id);
    glDetachShader(glshader->program, fs_id);
    glDeleteShader(vs_id);
    glDeleteShader(fs_id);
}

static void gl_shader_destroy(shader_t* shader) {
    gl_shader_internal_t* glshader = gfx_respool_internal(gfx_ctx.shader_pool, shader->internal);
    if(!glshader) return;
    glDeleteProgram(glshader->program);
    gfx_respool_free_internal(gfx_ctx.shader_pool, shader->internal);
}

static void gl_shader_update_uniforms(shader_t* shader, range_t uniforms) {
    gl_shader_internal_t* glshader = gfx_respool_internal(gfx_ctx.shader_pool, shader->internal);
    if(!glshader) return;
    u32 read_size = 0;
    for(u32 i = 0; i < shader->uniform_block.num; i ++) {
        uniform_t uniform = shader->uniform_block.uniforms[i];
        u32 size = uniform_type_get_bytes(uniform.type);
        if(size == 0) continue;

        void* curr = uniforms.ptr + read_size;
        switch(uniform.type) {
            case UNIFORM_TYPE_i32:
                glUniform1iv(uniform.glid, 1, (i32*)curr);
                break;
            case UNIFORM_TYPE_u32:
                glUniform1uiv(uniform.glid, 1, (u32*)curr);
                break;
            case UNIFORM_TYPE_f32:
                glUniform1fv(uniform.glid, 1, (f32*)curr);
                break;
            case UNIFORM_TYPE_v2i:
                glUniform2iv(uniform.glid, 1, (i32*)curr);
                break;
            case UNIFORM_TYPE_v2f:
                glUniform2fv(uniform.glid, 1, (f32*)curr);
                break;
            case UNIFORM_TYPE_v3i:
                glUniform3iv(uniform.glid, 1, (i32*)curr);
                break;
            case UNIFORM_TYPE_v3f:
                glUniform3fv(uniform.glid, 1, (f32*)curr);
                break;
            case UNIFORM_TYPE_v4i:
                glUniform4iv(uniform.glid, 1, (i32*)curr);
                break;
            case UNIFORM_TYPE_v4f:
                glUniform4fv(uniform.glid, 1, (f32*)curr);
                break;
            case UNIFORM_TYPE_mat4:
                glUniformMatrix4fv(uniform.glid, 1, false, (f32*)curr);
                break;
            default: UNREACHABLE; break;
        }

        read_size += size;
        if(read_size > uniforms.size) {
            LOG_ERR("tried to write more data than was provided. ignoring.\n");
            return;
        }
    }
}
